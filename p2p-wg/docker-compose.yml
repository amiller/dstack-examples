version: "3.8"

services:
  node:
    build:
      context: .
      dockerfile_inline: |
        FROM python:3.11-slim
        RUN apt-get update && \
            apt-get install -y --no-install-recommends \
                wireguard-tools \
                iproute2 \
                curl \
                ca-certificates \
                iputils-ping \
                net-tools \
                tcpdump && \
            apt-get clean && \
            rm -rf /var/lib/apt/lists/*
        RUN python -m venv /venv && \
            . /venv/bin/activate && \
            pip install --no-cache-dir pystun3 requests
    container_name: p2pnode
    restart: unless-stopped
    cap_add: [ "NET_ADMIN", "SYS_MODULE" ]
    devices: [ "/dev/net/tun:/dev/net/tun" ]
    sysctls:
      net.ipv4.ip_forward: "1"
      net.ipv4.conf.all.src_valid_mark: "1"
    ports:
      - "8080:8080"  # publishes /node.json
    command: |
      bash -c '
      set -euo pipefail &&
      . /venv/bin/activate &&
      mkdir -p /app &&
      cat > /app/node.py << "EOF"
      import json, os, time, threading, subprocess, http.server
      from datetime import datetime, timezone
      import requests, stun
      GIST_URL = "https://gist.githubusercontent.com/amiller/465888c57bfce42dd06f5cb052ea206c/raw/urls.json"
      HTTP_BIND = "0.0.0.0:8080"
      WG_IFACE = "wg0"
      WG_PORT = 51820
      BASE_OCTET = 10
      LOCK = threading.Lock()
      STATE = {
        "wg_pubkey": "", "overlay_ip": "", "self_index": None,
        "wg_listen_port": WG_PORT, "public_ip": None, "public_port": None,
        "nat": None, "updated_at": "", "self_url": None,
      }
      PEERS_JSON = {}
      PEER_ENDPOINTS = {}
      PEER_INDEX = {}
      def sh(cmd, check=True, input=None):
          p = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, input=input)
          if check and p.returncode != 0:
              raise RuntimeError(f"cmd failed: {cmd}\\n{p.stderr}")
          return p.stdout.strip()
      def ensure_keys():
          os.makedirs("/etc/wireguard", exist_ok=True)
          keyfile = "/etc/wireguard/privatekey"
          if os.path.exists(keyfile): os.remove(keyfile)
          priv = sh("wg genkey")
          with open(keyfile, "w") as f: f.write(priv + "\n")
          os.chmod(keyfile, 0o600)
          return priv, sh("wg pubkey", input=priv + "\n")

      def ensure_wg_iface(priv):
          try: sh(f"ip link show {WG_IFACE}")
          except: sh(f"ip link add {WG_IFACE} type wireguard")
          sh(f"wg set {WG_IFACE} listen-port {WG_PORT}")
          sh(f"wg set {WG_IFACE} private-key /dev/stdin", input=priv+"\n")
          sh(f"ip link set up dev {WG_IFACE}")

      def current_overlay_ip():
          out = sh(f"ip -o addr show dev {WG_IFACE}", check=False)
          for line in out.splitlines():
              parts = line.split()
              if len(parts) >= 4 and parts[2] == "inet": return parts[3]
          return None

      def ip_for_index(i: int) -> str:
          host = BASE_OCTET + i
          if host <= 1: host = 10
          if host >= 254: host = 200
          return f"10.88.0.{host}/32"
      def ensure_overlay_addr(desired_cidr: str):
          cur = current_overlay_ip()
          if cur == desired_cidr: return
          if cur and cur.endswith("/32") and cur.startswith("10.88.0."):
              sh(f"ip addr del {cur} dev {WG_IFACE}", check=False)
          sh(f"ip addr add {desired_cidr} dev {WG_IFACE}", check=False)

      def logs_status():
          try:
              status = sh(f"wg show {WG_IFACE}")
              transfer = sh(f"wg show {WG_IFACE} transfer")
              for line in transfer.splitlines():
                  if line.strip():
                      peer, rx, tx = line.split()
                      print(f"[wg] traffic rx={rx}B tx={tx}B", flush=True)
                      if int(rx) > 0 or int(tx) > 0:
                          return True
              for line in status.splitlines():
                  if "latest handshake:" in line.lower():
                      parts = line.lower().split("latest handshake:")[1].strip().split()
                      if "minute" in parts[1]:
                          mins = int(parts[0])
                          print(f"[wg] handshake {mins}m ago", flush=True)
              return False
          except: return False

      def wg_down():
          try:
              sh(f"ip link show {WG_IFACE}")
              sh(f"ip link set down dev {WG_IFACE}")
              sh(f"ip link del {WG_IFACE}")
          except:
              pass

      def wg_set_peer(pub: str, allowed_cidr: str, endpoint: str, keepalive: int=25):
          cmd = f"wg set {WG_IFACE} peer {pub} allowed-ips {allowed_cidr}"
          if endpoint:
              cmd += f" endpoint {endpoint}"
          if keepalive > 0:
              cmd += f" persistent-keepalive {keepalive}"
          sh(cmd)
          # Add route for peer allowed IPs through WireGuard interface
          sh(f"ip route replace {allowed_cidr} dev {WG_IFACE}")
      def now_iso(): return datetime.now(timezone.utc).isoformat()
      class Handler(http.server.BaseHTTPRequestHandler):
          def do_GET(self):
              if self.path.startswith("/node.json"):
                  with LOCK:
                      body = {
                          "wg_pubkey": STATE["wg_pubkey"],
                          "overlay_ip": STATE["overlay_ip"],       # convenient echo; derived from index
                          "wg_listen_port": STATE["wg_listen_port"],
                          "public_ip": STATE["public_ip"],
                          "public_port": STATE["public_port"],
                          "nat": STATE["nat"],
                          "updated_at": STATE["updated_at"],
                          "self_url": STATE["self_url"],
                          "self_index": STATE["self_index"],
                      }
                  b = json.dumps(body).encode()
                  self.send_response(200); self.send_header("content-type","application/json")
                  self.send_header("content-length", str(len(b))); self.end_headers(); self.wfile.write(b)
              elif self.path == "/healthz":
                  self.send_response(200); self.end_headers(); self.wfile.write(b"ok")
              else:
                  self.send_response(404); self.end_headers()
          def log_message(self, *a): return
      def run_http():
          host, port = HTTP_BIND.split(":")
          http.server.ThreadingHTTPServer((host, int(port)), Handler).serve_forever()
      def fetch_json(url, timeout=5):
          r = requests.get(url, timeout=timeout)
          r.raise_for_status()
          return r.json()
      def do_stun_check():
          """Perform a single STUN check with WireGuard down"""
          try:
              with LOCK:
                  priv_key = STATE.get("wg_privkey")
              if priv_key:
                  wg_down()
                  time.sleep(1)
              nat, ext_ip, ext_port = stun.get_ip_info(stun_host="stun.l.google.com", stun_port=19302, source_port=WG_PORT)
              with LOCK:
                  STATE["public_ip"], STATE["public_port"], STATE["nat"] = ext_ip, ext_port, nat
                  STATE["updated_at"] = now_iso()
              print(f"[stun] {nat} {ext_ip}:{ext_port}", flush=True)
              return True
          except:
              return False
          finally:
              if priv_key:
                  try:
                      ensure_wg_iface(priv_key)
                      if STATE["overlay_ip"]:
                          ensure_overlay_addr(STATE["overlay_ip"])
                      for pub, idx in PEER_INDEX.items():
                          if pub in PEER_ENDPOINTS:
                              wg_set_peer(pub, ip_for_index(idx), PEER_ENDPOINTS[pub])
                      listing = fetch_json(GIST_URL)
                      urls = listing.get("peers") if isinstance(listing, dict) else (listing if isinstance(listing, list) else [])
                      reconfigure_from_gist(urls)
                  except:
                      pass

      def stun_loop():
          last_check = 0
          check_interval = 60  # Check every 60 seconds when no peers
          
          while True:
              try:
                  now = time.time()
                  
                  # Skip check if peers are connected
                  if logs_status():
                      time.sleep(10)  # Quick sleep when connected
                      continue
                  
                  # Do STUN check if enough time has passed
                  if now - last_check >= check_interval:
                      if do_stun_check():
                          last_check = now
                  
                  time.sleep(10)  # Base sleep between checks
                  
              except Exception as e:
                  print(f"[stun] loop error: {e}", flush=True)
                  time.sleep(10)
      def reconfigure_from_gist(peers_list):
          docs = {}
          for idx, url in enumerate(peers_list):
              try:
                  print(f"[peer] fetch {url}", flush=True)
                  doc = fetch_json(url)
                  docs[url] = doc
                  if pub := doc.get("wg_pubkey"):
                      PEER_INDEX[pub] = idx
              except: pass

          with LOCK:
              mypub = STATE["wg_pubkey"]
              # Find self first
              for idx, url in enumerate(peers_list):
                  if doc := docs.get(url):
                      if doc.get("wg_pubkey") == mypub:
                          if STATE["self_url"] != url or STATE["self_index"] != idx:
                              STATE["self_url"] = url
                              STATE["self_index"] = idx
                              STATE["overlay_ip"] = ip_for_index(idx)
                              ensure_overlay_addr(STATE["overlay_ip"])
                          break
              else: return

              # Find current pubkey for each position (excluding our position)
              position_keys = {}
              for idx, url in enumerate(peers_list):
                  if idx == STATE["self_index"]: continue
                  doc = docs.get(url)
                  if not doc: continue
                  pub = doc.get("wg_pubkey")
                  if not pub: continue
                  position_keys[idx] = pub

              # Remove old peers that arent in their positions anymore
              for old_pub, old_idx in list(PEER_INDEX.items()):
                  if old_pub == mypub: continue  # Never remove ourselves
                  if old_idx in position_keys and position_keys[old_idx] == old_pub: continue
                  try:
                      sh(f"wg set {WG_IFACE} peer {old_pub} remove")
                      print(f"[wg] removed old peer {old_pub[:8]} from position {old_idx}", flush=True)
                      del PEER_INDEX[old_pub]
                      if old_pub in PEER_ENDPOINTS: del PEER_ENDPOINTS[old_pub]
                  except: pass

              # Configure current peers
              for idx, url in enumerate(peers_list):
                  doc = docs.get(url)
                  if not doc: continue
                  pub = doc.get("wg_pubkey")
                  if not pub or pub == mypub: continue
                  
                  pip, pport = doc.get("public_ip"), doc.get("public_port")
                  endpoint = f"{pip}:{pport}" if pip and pport else ""
                  
                  try:
                      wg_set_peer(pub, ip_for_index(idx), endpoint, keepalive=25 if endpoint else 0)
                      PEER_INDEX[pub] = idx
                      if not endpoint: continue
                      
                      old_endpoint = PEER_ENDPOINTS.get(pub)
                      PEER_ENDPOINTS[pub] = endpoint
                      if old_endpoint == endpoint: continue
                      
                      print(f"[wg] peer {pub[:8]} at position {idx} endpoint {endpoint}", flush=True)
                      print(sh(f"wg show {WG_IFACE}"), flush=True)
                  except: pass
              
              # Update stored docs after successful reconfiguration
              for u,d in docs.items(): PEERS_JSON[u] = d
      def gist_loop():
          last_urls = None
          last_check = 0
          CHECK_INTERVAL = 30  # seconds
          while True:
              try:
                  now = time.time()
                  listing = fetch_json(GIST_URL)
                  urls = listing.get("peers") if isinstance(listing, dict) else (listing if isinstance(listing, list) else [])
                  if urls != last_urls or now - last_check >= CHECK_INTERVAL:
                      last_check = now
                      reconfigure_from_gist(urls)
                      last_urls = urls

                  for url, doc in list(PEERS_JSON.items()):
                      try:
                          if (newdoc := fetch_json(url)) == doc: continue
                          PEERS_JSON[url] = newdoc
                          if not (pub := newdoc.get("wg_pubkey")) or pub == STATE["wg_pubkey"]: continue
                          pip, pport = newdoc.get("public_ip"), newdoc.get("public_port")
                          endpoint = f"{pip}:{pport}" if pip and pport else ""
                          if not endpoint: continue
                          if not (idx := PEER_INDEX.get(pub)): continue
                          overlay = ip_for_index(idx)
                          if PEER_ENDPOINTS.get(pub) == endpoint: continue
                          try:
                              wg_set_peer(pub, overlay, endpoint, keepalive=25)
                              PEER_ENDPOINTS[pub] = endpoint
                          except: pass
                      except: continue
              except: pass
              time.sleep(15)
      class TestHandler(http.server.BaseHTTPRequestHandler):
          def do_GET(self):
              if self.path == "/test":
                  with LOCK:
                      b = json.dumps({"wg_ip": STATE["overlay_ip"], "time": now_iso()}).encode()
                  print(f"[http] serving request from {self.client_address[0]}", flush=True)
                  self.send_response(200)
                  self.send_header("content-type", "application/json")
                  self.send_header("content-length", str(len(b)))
                  self.end_headers()
                  self.wfile.write(b)
              else:
                  self.send_response(404)
                  self.end_headers()
          def log_message(self, *a): return

      def run_test_server():
          while True:
              try:
                  if not STATE["overlay_ip"]:
                      time.sleep(1)
                      continue
                  wg_ip = STATE["overlay_ip"].split("/")[0]
                  server = http.server.ThreadingHTTPServer((wg_ip, 8000), TestHandler)
                  server.serve_forever()
              except Exception:
                  time.sleep(5)

      def main():
          priv, pub = ensure_keys()
          with LOCK:
              STATE["wg_privkey"] = priv  # Store private key for STUN cycle
              STATE["wg_pubkey"] = pub
              STATE["updated_at"] = now_iso()
          ensure_wg_iface(priv)  # key+port only; overlay set after we learn our index
          threading.Thread(target=run_http, daemon=True).start()
          threading.Thread(target=stun_loop, daemon=True).start()
          threading.Thread(target=gist_loop, daemon=True).start()
          threading.Thread(target=run_test_server, daemon=True).start()
          
          # Periodically test connectivity to other nodes
          while True:
              try:
                  if not STATE["overlay_ip"] or STATE["self_index"] is None: continue
                  # Try other nodes in the network
                  for idx, url in enumerate(fetch_json(GIST_URL)):
                      if idx == STATE["self_index"]: continue
                      other_ip = ip_for_index(idx).split("/")[0]
                      try:
                          r = requests.get(f"http://{other_ip}:8000/test", timeout=1)
                          print(f"[http] connected to {other_ip}: {r.json()}", flush=True)
                      except:
                          pass
              except:
                  pass
              time.sleep(10)
      if __name__ == "__main__":
          main()
      EOF
      python /app/node.py
      '
